const express = require('express');
const chokidar = require('chokidar');
const { WebSocketServer } = require('ws');
const http = require('http');
const logger = require('./logger');
const path = require('path');
const cors = require('cors');
const {
  EXTENSIONS_MESSAGE_VERSION,
  WEBSOCKET_MESSAGE_VERSION,
} = require('./constants');

function startDevServer(outputDir, port, extensionConfig) {
  const callback = `http://hslocal.net:${port}/${extensionConfig?.output}`;

  const app = express();

  // Using http.createServer so WebSocket server can be attached before initializing express.
  const server = http.createServer(app);

  // Setup middleware
  app.use(cors());
  app.use(express.static(outputDir));

  _addExtensionsEndpoint(app, port);

  const { broadcast, wss } = _setupWebSocketServer(
    server,
    extensionConfig,
    callback
  );
  _setupChokidarWatcher(broadcast, outputDir);

  server.listen({ port }, () => {
    logger.warn(`Listening at ${callback}`);
  });

  _configureShutDownHandlers(server, wss, broadcast);
}

function _setupWebSocketServer(server, extensionConfig, callback) {
  const wss = new WebSocketServer({ server });

  const baseMessage = {
    appName: extensionConfig?.appName,
    title: extensionConfig?.name,
    callback,
    version: WEBSOCKET_MESSAGE_VERSION,
  };

  wss.on('connection', client => {
    logger.info('Browser connected and listening for bundle updates');
    client.send(
      JSON.stringify({
        event: 'start',
        ...baseMessage,
      })
    );
  });

  return {
    wss,
    broadcast: message => {
      if (wss.clients.size === 0) {
        logger.warn('No browsers connected to notify');
        return;
      }
      wss.clients.forEach(client => {
        client.send(
          JSON.stringify({
            ...message,
            ...baseMessage,
          })
        );
      });
    },
  };
}

// Setup a watcher on the dist directory and update broadcast
//to all clients when an event is observed
function _setupChokidarWatcher(broadcast, outputDir) {
  chokidar.watch(outputDir).on('all', (event, file) => {
    if (event !== 'change' || event !== 'add' || file === 'manifest.json') {
      // We need to listen to 'change' and 'add' because sometimes chokidar
      // sees it as an 'unlink' and 'add' instead of just a 'change'
      // Since we are adding the manifest.json to the build, we want to ignore changes to that so we don't double send messages
      return;
    }
    logger.info('Bundle updated notifying browser');
    broadcast({
      event: 'update',
    });
  });
}

function _addExtensionsEndpoint(server, port) {
  const endpoint = '/extensions';
  server.get(endpoint, (_req, res) => {
    try {
      const manifest = require(path.join(process.cwd(), 'dist/manifest.json'));
      const {
        extension: { appName, name, output },
      } = manifest;

      const response = {
        websocket: `ws://localhost:${port}`,
        version: EXTENSIONS_MESSAGE_VERSION,
        extensions: [
          {
            appName,
            title: name,
            callback: `http://hslocal.net:${port}/${output}`,
            manifest: {
              ...manifest,
              extension: undefined,
            },
          },
        ],
      };
      res.status(200).json(response);
    } catch (e) {
      res.status(500).json({
        message: 'Unable to load manifest file',
      });
    }
  });
  logger.warn(`Listening at http://hslocal.net:${port}${endpoint}`);
}

function _configureShutDownHandlers(server, wss, broadcast) {
  function shutdown() {
    logger.warn('\nCleaning up after ourselves...');
    // Stop new connections to express server
    broadcast({
      event: 'shutdown',
    });
    wss.close(() => {});
    server.close(() => {});
    logger.warn('Clean up done');
    process.exit(0);
  }

  process.on('SIGINT', shutdown);
  process.on('SIGTERM', shutdown);
}

module.exports = startDevServer;
