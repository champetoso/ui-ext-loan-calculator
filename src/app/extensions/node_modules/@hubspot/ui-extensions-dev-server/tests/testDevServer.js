const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const assert = require('assert');
const http = require('http');
const WebSocket = require('ws');
const {
  WEBSOCKET_MESSAGE_VERSION,
  EXTENSIONS_MESSAGE_VERSION,
} = require('../constants');

const testResults = {
  buildTestPassed: false,
  expressStaticTestPassed: false,
  extensionsEndpointPassed: false,
  webSocketTestPassed: false,
};

const port = 5172;
const host = 'hslocal.net';

function testDevServer(logger, devServerProcess) {
  logger.warn('\nDev Server Tests started ðŸ¤ž');

  // We need to use spawn here because it will put the process into the background,
  // which is required because dev mode is a blocking process and we want to test that
  // the express server and websocket server are starting properly
  devServerProcess = spawn('hs-ui-extensions-dev-server', [
    'dev',
    '--extension',
    'PhoneLines.tsx',
    '--port',
    `${port}`,
  ]);

  devServerProcess.stdout.on('data', buffer => {
    const data = buffer.toString().toLowerCase();
    if (data.includes('built in')) {
      testBuild(testResults, logger);
    }
    if (
      data.includes('listening') &&
      data.includes(`${host}:${port}/extensions`)
    ) {
      setTimeout(() => {
        testExpressServer(testResults, logger);
        testWebSocketServer(testResults, logger);
      }, 1000);
    }
  });

  // If the dev server writes to stderr, log the error and throw a new error
  devServerProcess.stderr.on('data', buffer => {
    const data = buffer.toString();
    logger.error(data.toString());
    throw new Error(data);
  });

  // When the process closes make sure we met all the success conditions
  devServerProcess.on('close', () => {
    if (metConditions()) {
      logger.info('Dev Server Tests passed ðŸš€');
    } else {
      console.log(testResults);
      logger.error('Tests failed ðŸ˜­');
    }
  });

  const interval = setInterval(callback, 1000);
  let count = 0;
  function callback() {
    count += 1;
    if (metConditions() || count === 5) {
      devServerProcess.kill();
      clearInterval(interval);
    }
  }
}

function metConditions() {
  const {
    buildTestPassed,
    expressStaticTestPassed,
    extensionsEndpointPassed,
    webSocketTestPassed,
  } = testResults;
  return (
    buildTestPassed &&
    expressStaticTestPassed &&
    extensionsEndpointPassed &&
    webSocketTestPassed
  );
}

// Test that the files were built in the proper location and spot
// check the contents of the files.
function testBuild(results, logger) {
  // // Make sure the files are getting generated in the dist dir
  const distDir = path.join(process.cwd(), 'dist');
  const filesInOutputDir = fs.readdirSync(distDir);
  assert.deepStrictEqual(filesInOutputDir, ['PhoneLines.js', 'manifest.json']);
  const fileContents = fs
    .readFileSync(path.join(distDir, filesInOutputDir[0]))
    .toString();
  const stringsToSpotCheck = [
    '.createRemoteReactComponent',
    '.createElement',
    'hubspot.extend',
    'React',
    'RemoteUI',
  ];
  stringsToSpotCheck.forEach(stringToCheck => {
    assert(
      fileContents.includes(stringToCheck),
      `File ${filesInOutputDir[0]} contents should contain: "${stringToCheck}"`
    );
  });
  logger.info('- Build succeeded ðŸš€');
  results.buildTestPassed = true;
}

// Test that the express server is running on the expected port
// and that it is serving the files as expected.
function testExpressServer(results, logger) {
  http.get(
    {
      host,
      port,
      path: '/PhoneLines.js',
    },
    response => {
      if (response.statusCode !== 200) {
        throw Error('Error with express server');
      }
      logger.info('- Express server connected and serving files ðŸš€');
      results.expressStaticTestPassed = true;
    }
  );
  http.get(
    {
      host,
      port,
      path: '/extensions',
    },
    response => {
      let body = '';
      response.on('data', chunk => {
        body += chunk.toString();
      });
      response.on('end', () => {
        assert(response.statusCode === 200);
        body = JSON.parse(body);
        assert(body.extensions);
        assert.equal(body.extensions.length, 1);
        const extension = body.extensions.pop();
        assert(extension.manifest);
        assert.equal(extension.appName, 'Example App React UI');
        assert.equal(extension.title, 'Phone Lines');
        assert.equal(
          extension.callback,
          `http://${host}:${port}/PhoneLines.js`
        );
        assert.equal(body.websocket, `ws://localhost:${port}`);
        assert.strictEquals(body.version, EXTENSIONS_MESSAGE_VERSION);
        logger.info('- Express serving extension data ðŸš€');
        results.extensionsEndpointPassed = true;
      });
    }
  );
}

// Test the the web socket server is running on the expected port and
// that we are able to receive messages from it.
function testWebSocketServer(results, logger) {
  const ws = new WebSocket(`ws://localhost:${port}`);
  ws.on('message', messageBuffer => {
    const message = JSON.parse(messageBuffer.toString());
    assert(message.event === 'start');
    assert.strictEqual(message.appName, 'Example App React UI');
    assert.strictEqual(message.title, 'Phone Lines');
    assert.strictEqual(message.version, WEBSOCKET_MESSAGE_VERSION);
    logger.info('- WebSocket server connected and sending messages ðŸš€');
    results.webSocketTestPassed = true;
    ws.close(); // The test passed, close the connection
  });
}

module.exports = {
  testDevServer,
};
